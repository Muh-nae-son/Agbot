#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SparkFun_BNO080_Arduino_Library.h>

BNO080 imu;

// SD card
File logFile;
const int SD_CS = 15;   // D8 on ESP8266

// IMU I2C pins
const int I2C_SDA = 4;  // D2
const int I2C_SCL = 5;  // D1

// Quaternion reference for reset
float q0_ref = 1, q1_ref = 0, q2_ref = 0, q3_ref = 0;

// Quaternion multiply
void quatMultiply(float &w, float &x, float &y, float &z,
                  float w2, float x2, float y2, float z2)
{
  float nw = w*w2 - x*x2 - y*y2 - z*z2;
  float nx = w*x2 + x*w2 + y*z2 - z*y2;
  float ny = w*y2 - x*z2 + y*w2 + z*x2;
  float nz = w*z2 + x*y2 - y*x2 + z*w2;

  w = nw; x = nx; y = ny; z = nz;
}

// Quaternion â†’ Euler angles
void quatToEuler(float w, float x, float y, float z,
                 float &yaw, float &pitch, float &roll)
{
  yaw = atan2f(2.0f * (w*z + x*y),
               1.0f - 2.0f * (y*y + z*z)) * 57.2958f;

  float sinp = 2.0f * (w*y - z*x);
  if (fabs(sinp) >= 1)
    pitch = copysignf(90.0f, sinp);
  else
    pitch = asinf(sinp) * 57.2958f;

  roll = atan2f(2.0f * (w*x + y*z),
                1.0f - 2.0f * (x*x + y*y)) * 57.2958f;
}

// Create next available file LOGxxx.CSV
bool createLogFile()
{
  char filename[16];

  for (int i = 1; i < 1000; i++) {
    sprintf(filename, "/LOG%03d.CSV", i);

    if (!SD.exists(filename)) {
      logFile = SD.open(filename, FILE_WRITE);
      if (!logFile) return false;

      Serial.print("Logging to: ");
      Serial.println(filename);

      logFile.println("time_ms,yaw,pitch,roll,gx,gy,gz,qw,qx,qy,qz");
      logFile.flush();
      return true;
    }
  }
  return false;
}

void setup()
{
  Serial.begin(115200);
  delay(200);

  Serial.println("\nStarting ESP8266 IMU logger...");

  // Start I2C
  Wire.begin(I2C_SDA, I2C_SCL);

  // ***** IMPORTANT: SparkFun board needs full boot time *****
  Serial.println("Waiting for IMU power-up...");
  delay(800);   // <-- This is critical for BNO086 on ESP8266

  // Optional soft reset
  imu.softReset();
  delay(400);   // Allow SH-2 firmware to reload

  // Initialize SD card
  if (!SD.begin(SD_CS)) {
    Serial.println("SD init failed!");
    while (1);
  }
  Serial.println("SD card OK.");

  if (!createLogFile()) {
    Serial.println("Could not create log file!");
    while (1);
  }

  // Initialize IMU
  Serial.println("Initializing IMU...");
  if (!imu.begin()) {
    Serial.println("IMU not detected!");
    while (1);
  }

  imu.enableGameRotationVector(100);  // Drift-free orientation
  imu.enableGyro(100);                // Angular velocity

  Serial.println("IMU ready. Type 'r' to reset orientation.");
}

uint32_t sampleCount = 0;

void loop()
{
  // Handle serial reset: 'r' resets quaternion reference
  if (Serial.available()) {
    char c = Serial.read();
    if (c == 'r' || c == 'R') {

      float qw = imu.getQuatReal();
      float qx = imu.getQuatI();
      float qy = imu.getQuatJ();
      float qz = imu.getQuatK();

      q0_ref =  qw;
      q1_ref = -qx;
      q2_ref = -qy;
      q3_ref = -qz;

      Serial.println("Orientation reset.");
    }
  }

  // IMU data available
  if (imu.dataAvailable()) {

    float w = imu.getQuatReal();
    float x = imu.getQuatI();
    float y = imu.getQuatJ();
    float z = imu.getQuatK();

    // Apply "zero" quaternion
    quatMultiply(w, x, y, z, q0_ref, q1_ref, q2_ref, q3_ref);

    float yaw, pitch, roll;
    quatToEuler(w, x, y, z, yaw, pitch, roll);

    float gx = imu.getGyroX();
    float gy = imu.getGyroY();
    float gz = imu.getGyroZ();

    uint32_t t = millis();

    // Write CSV
    logFile.print(t); logFile.print(',');
    logFile.print(yaw); logFile.print(',');
    logFile.print(pitch); logFile.print(',');
    logFile.print(roll); logFile.print(',');
    logFile.print(gx); logFile.print(',');
    logFile.print(gy); logFile.print(',');
    logFile.print(gz); logFile.print(',');
    logFile.print(w);  logFile.print(',');
    logFile.print(x);  logFile.print(',');
    logFile.print(y);  logFile.print(',');
    logFile.println(z);

    // Flush occasionally
    if (++sampleCount % 50 == 0) {
      logFile.flush();
    }
  }

  delay(2);
}
